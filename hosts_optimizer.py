#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Hosts ÈÄâ‰ºòËÑöÊú¨
Áî®‰∫éÊµãËØï ar-gcp-cdn.bistudio.com ÁöÑ‰∏çÂêå IP Âú∞ÂùÄÂª∂ËøüÔºåÂπ∂ÈÄâÊã©ÊúÄ‰ºòÁöÑ IP Êõ¥Êñ∞Âà∞ hosts Êñá‰ª∂
"""

import socket
import time
import subprocess
import platform
import os
import sys
import json
import statistics
import hashlib
import random
from typing import List, Dict, Tuple
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
import dns.resolver
import requests
from urllib.parse import urlparse
import urllib3
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import ssl
import socket
from datetime import datetime


class EnhancedDNSResolver:
    """Â¢ûÂº∫ÁöÑDNSËß£ÊûêÂô®"""
    
    def __init__(self, domain: str):
        self.domain = domain
        self.found_ips = set()
        self.dns_cache = {}  # DNSÊü•ËØ¢ÁºìÂ≠ò
        self.verified_ips = set()  # Â∑≤È™åËØÅÁöÑIP
        
    def resolve_all_ips(self) -> List[str]:
        """‰ΩøÁî®ÁúüÊ≠£ÁöÑÂπ∂Ë°åÊ®°ÂºèËß£ÊûêÂüüÂêçIPÔºàÈÅøÂÖçÊú¨Âú∞DNSÔºâ"""
        print(f"Ê≠£Âú®ÂÖ®Èù¢Ëß£Êûê {self.domain} ÁöÑIPÂú∞ÂùÄ...")
        print("‚ö†Ô∏è Ê≥®ÊÑèÔºö‰∏∫ÈÅøÂÖçDNSÊ±°ÊüìÔºå‰∏ç‰ΩøÁî®Êú¨Âú∞DNSËß£Êûê")
        print("üöÄ ‰ΩøÁî®Âπ∂Ë°åÊ®°ÂºèÔºåÊâÄÊúâDNSÊúçÂä°Âô®ÂêåÊó∂Êü•ËØ¢...")
        
        # Êî∂ÈõÜÊâÄÊúâDNSÊúçÂä°Âô®
        all_dns_servers = self._collect_all_dns_servers()
        print(f"üì° ÂÖ±Êî∂ÈõÜÂà∞ {len(all_dns_servers)} ‰∏™ÊùÉÂ®ÅDNSÊúçÂä°Âô®")
        
        # ÁúüÊ≠£Âπ∂Ë°åÊü•ËØ¢ÊâÄÊúâDNSÊúçÂä°Âô®
        with ThreadPoolExecutor(max_workers=min(50, len(all_dns_servers))) as executor:
            futures = {
                executor.submit(self._query_single_dns, dns_server): dns_server 
                for dns_server in all_dns_servers
            }
            
            completed = 0
            for future in as_completed(futures, timeout=10):
                try:
                    future.result()
                    completed += 1
                    if completed % 10 == 0:  # ÊØèÂÆåÊàê10‰∏™ÊòæÁ§∫ËøõÂ∫¶
                        print(f"üìä DNSÊü•ËØ¢ËøõÂ∫¶: {completed}/{len(all_dns_servers)}")
                except Exception:
                    continue
        
        # È™åËØÅÊâæÂà∞ÁöÑIPÂú∞ÂùÄ
        self._verify_found_ips()
        
        ip_list = list(self.found_ips)
        print(f"\nÊÄªÂÖ±ÊâæÂà∞ {len(ip_list)} ‰∏™ÂîØ‰∏ÄIPÂú∞ÂùÄ:")
        for i, ip in enumerate(ip_list, 1):
            print(f"{i:2d}. {ip}")
        
        return ip_list
    
    def _collect_all_dns_servers(self) -> List[str]:
        """Êî∂ÈõÜÊâÄÊúâÂèØÁî®ÁöÑDNSÊúçÂä°Âô®"""
        all_servers = []
        
        # ‰∏ªË¶ÅÂÖ¨ÂÖ±DNSÊúçÂä°Âô®
        all_servers.extend([
            "8.8.8.8", "8.8.4.4",  # Google DNS
            "1.1.1.1", "1.0.0.1",  # Cloudflare DNS
            "208.67.222.222", "208.67.220.220",  # OpenDNS
            "9.9.9.9", "149.112.112.112",  # Quad9 DNS
        ])
        
        # ‰∏≠ÂõΩ‰∏ªË¶ÅDNSÊúçÂä°Âô®
        all_servers.extend([
            "114.114.114.114", "114.114.115.115",  # 114 DNS
            "223.5.5.5", "223.6.6.6",  # ÈòøÈáåDNS
            "180.76.76.76",  # ÁôæÂ∫¶DNS
            "119.29.29.29", "182.254.116.116",  # ËÖæËÆØDNS
            "117.50.10.10", "52.80.52.52",  # ËÖæËÆØDNSÂ§áÁî®
            "123.125.81.6", "123.125.81.7",  # ÁôæÂ∫¶DNSÂ§áÁî®
        ])
        
        # ÂõΩÈôÖÊùÉÂ®ÅDNSÊúçÂä°Âô®
        all_servers.extend([
            "76.76.19.61", "76.76.2.22",  # ControlD
            "94.140.14.14", "94.140.15.15",  # AdGuard DNS
            "185.228.168.9", "185.228.169.9",  # CleanBrowsing
            "84.200.69.80", "84.200.70.40",  # DNS.WATCH
            "8.26.56.26", "8.20.247.20",  # Comodo Secure DNS
            "195.46.39.39", "195.46.39.40",  # SafeDNS
            "77.88.8.8", "77.88.8.1",  # Yandex DNS
            "45.90.28.0", "45.90.30.0",  # NextDNS
            "9.9.9.10", "149.112.112.10",  # Quad9 (ËøáÊª§)
            "1.1.1.2", "1.0.0.2",  # Cloudflare (ËøáÊª§)
            "1.1.1.3", "1.0.0.3",  # Cloudflare (ÊÅ∂ÊÑèËΩØ‰ª∂ËøáÊª§)
        ])
        
        # CDNÂíå‰∫ëÊúçÂä°Êèê‰æõÂïÜDNS
        all_servers.extend([
            "199.85.126.10", "199.85.127.10",  # Norton ConnectSafe
            "156.154.70.1", "156.154.71.1",  # Neustar DNS
            "64.6.64.6", "64.6.65.6",  # Verisign DNS
            "205.251.198.6", "205.251.198.7",  # AWS DNS
            "205.251.199.6", "205.251.199.7",  # AWS DNSÂ§áÁî®
            "168.63.129.16",  # Azure DNS
            "40.74.0.1", "40.74.0.2",  # AzureÂÖ¨ÂÖ±DNS
        ])
        
        # Âå∫ÂüüÁâπÂÆöDNSÊúçÂä°Âô®
        all_servers.extend([
            "168.126.63.1", "168.126.63.2",  # Èü©ÂõΩDNS
            "202.106.0.20", "202.106.46.151",  # ‰∏≠ÂõΩÁîµ‰ø°DNS
            "202.96.209.5", "202.96.209.133",  # ‰∏≠ÂõΩËÅîÈÄöDNS
        ])
        
        # ÂéªÈáçÂπ∂ËøîÂõû
        return list(set(all_servers))
    
    def _query_single_dns(self, dns_server: str):
        """Êü•ËØ¢Âçï‰∏™DNSÊúçÂä°Âô®"""
        # Ê£ÄÊü•ÁºìÂ≠ò
        cache_key = f"{dns_server}_{self.domain}"
        if cache_key in self.dns_cache:
            cached_ips = self.dns_cache[cache_key]
            for ip in cached_ips:
                if self._is_valid_ip(ip):
                    self.found_ips.add(ip)
                    print(f"‚úì {dns_server} (ÁºìÂ≠ò): {ip}")
            return
        
        try:
            resolver = dns.resolver.Resolver()
            resolver.nameservers = [dns_server]
            resolver.timeout = 0.5
            resolver.lifetime = 0.5
            
            answers = resolver.resolve(self.domain, 'A')
            found_ips = []
            for answer in answers:
                ip = str(answer)
                if self._is_valid_ip(ip):
                    self.found_ips.add(ip)
                    found_ips.append(ip)
                    print(f"‚úì {dns_server}: {ip}")
            
            # ÁºìÂ≠òÁªìÊûú
            if found_ips:
                self.dns_cache[cache_key] = found_ips
                
        except Exception:
            pass  # ÈùôÈªòÂøΩÁï•Â§±Ë¥•ÁöÑDNSÊü•ËØ¢
    
    def _verify_found_ips(self):
        """È™åËØÅÊâæÂà∞ÁöÑIPÂú∞ÂùÄÊòØÂê¶ÁúüÂÆûÊúâÊïàÔºàÂø´ÈÄüÊ®°ÂºèÔºâ"""
        print("\nÊ≠£Âú®Âø´ÈÄüÈ™åËØÅIPÂú∞ÂùÄÊúâÊïàÊÄß...")
        
        def verify_single_ip(ip):
            try:
                # Â∞ùËØïËøûÊé•Âà∞IPÁöÑ80Á´ØÂè£Ôºå‰ΩøÁî®Êõ¥Áü≠ÁöÑË∂ÖÊó∂Êó∂Èó¥
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                result = sock.connect_ex((ip, 80))
                sock.close()
                
                if result == 0:
                    self.verified_ips.add(ip)
                    print(f"‚úì È™åËØÅÈÄöËøá: {ip}")
                    return True
                else:
                    print(f"‚úó È™åËØÅÂ§±Ë¥•: {ip}")
                    return False
            except Exception:
                print(f"‚úó È™åËØÅÂ§±Ë¥•: {ip}")
                return False
        
        # Âπ∂Ë°åÈ™åËØÅIPÂú∞ÂùÄÔºåÂ¢ûÂä†Âπ∂ÂèëÊï∞
        with ThreadPoolExecutor(max_workers=30) as executor:
            futures = {executor.submit(verify_single_ip, ip): ip for ip in self.found_ips}
            
            for future in as_completed(futures):
                try:
                    future.result(timeout=2)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                except Exception:
                    continue
        
        # Âè™‰øùÁïôÈ™åËØÅÈÄöËøáÁöÑIP
        self.found_ips = self.verified_ips
        print(f"È™åËØÅÂÆåÊàêÔºåÊúâÊïàIPÊï∞Èáè: {len(self.found_ips)}")
    
    
    def _is_valid_ip(self, ip: str) -> bool:
        """HTTP DNSÊü•ËØ¢ÔºàDoHÊúçÂä°Ôºâ"""
        http_services = [
            # Google DoH
            f"https://dns.google/resolve?name={self.domain}&type=A",
            # Cloudflare DoH
            f"https://cloudflare-dns.com/dns-query?name={self.domain}&type=A",
            # OpenDNS DoH
            f"https://doh.opendns.com/dns-query?name={self.domain}&type=A",
            # Quad9 DoH
            f"https://dns.quad9.net:5053/dns-query?name={self.domain}&type=A",
            # AdGuard DoH
            f"https://dns.adguard.com/dns-query?name={self.domain}&type=A",
            # CleanBrowsing DoH
            f"https://doh.cleanbrowsing.org/doh/security-filter/dns-query?name={self.domain}&type=A",
            # ControlD DoH
            f"https://doh.controld.com/dns-query?name={self.domain}&type=A",
            # NextDNS DoH
            f"https://dns.nextdns.io/dns-query?name={self.domain}&type=A",
            # Mullvad DoH
            f"https://doh.mullvad.net/dns-query?name={self.domain}&type=A",
            # LibreDNS DoH
            f"https://doh.libredns.gr/dns-query?name={self.domain}&type=A"
        ]
        
        for service_url in http_services:
            try:
                response = requests.get(service_url, timeout=2)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                if response.status_code == 200:
                    data = response.json()
                    if 'Answer' in data:
                        for answer in data['Answer']:
                            if answer.get('type') == 1:
                                ip = answer.get('data', '').strip()
                                if self._is_valid_ip(ip):
                                    self.found_ips.add(ip)
                                    service_name = service_url.split('//')[1].split('/')[0]
                                    print(f"‚úì {service_name}: {ip}")
            except Exception:
                continue
    
    def _resolve_command_line(self):
        """ÂëΩ‰ª§Ë°åÂ∑•ÂÖ∑Ëß£Êûê"""
        # nslookup
        try:
            result = subprocess.run(['nslookup', self.domain], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    line = line.strip()
                    if 'Address:' in line and not line.startswith('#'):
                        ip = line.split('Address:')[-1].strip()
                        if self._is_valid_ip(ip):
                            self.found_ips.add(ip)
                            print(f"‚úì nslookup: {ip}")
        except Exception:
            pass
    
    def _resolve_powershell(self):
        """PowerShellËß£Êûê"""
        if platform.system().lower() == "windows":
            try:
                ps_command = f"Resolve-DnsName -Name {self.domain} -Type A | Select-Object -ExpandProperty IPAddress"
                result = subprocess.run(['powershell', '-Command', ps_command], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        ip = line.strip()
                        if self._is_valid_ip(ip):
                            self.found_ips.add(ip)
                            print(f"‚úì PowerShell: {ip}")
            except Exception:
                pass
    
    def _resolve_dig(self):
        """digÂëΩ‰ª§Ëß£Êûê"""
        if platform.system().lower() != "windows":
            try:
                result = subprocess.run(['dig', '+short', self.domain], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    for line in result.stdout.strip().split('\n'):
                        ip = line.strip()
                        if self._is_valid_ip(ip):
                            self.found_ips.add(ip)
                            print(f"‚úì dig: {ip}")
            except Exception:
                pass
    
    def _resolve_alternative_methods(self):
        """ÂÖ∂‰ªñËß£ÊûêÊñπÊ≥ï"""
        # Â∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑÊü•ËØ¢Á±ªÂûã
        try:
            # AAAAËÆ∞ÂΩïÔºàIPv6Ôºâ
            result = socket.getaddrinfo(self.domain, None, socket.AF_INET6)
            for item in result:
                ip = item[4][0]
                if self._is_valid_ip(ip):
                    self.found_ips.add(ip)
                    print(f"‚úì IPv6: {ip}")
        except Exception:
            pass
    
    def _resolve_international_dns(self):
        """ÂõΩÈôÖDNSÊúçÂä°Âô®Ëß£Êûê"""
        international_dns = [
            # Ê¨ßÊ¥≤DNS
            "84.200.69.80", "84.200.70.40",  # DNS.WATCH
            "77.109.148.136", "77.109.148.137",  # Freenom World
            "80.80.80.80", "80.80.81.81",  # Freenom World
            "91.239.100.100", "89.233.43.71",  # UncensoredDNS
            # ‰∫öÊ¥≤DNS
            "202.12.27.33", "202.12.27.34",  # Êó•Êú¨DNS
            "168.126.63.1", "168.126.63.2",  # Èü©ÂõΩDNS
            "202.106.0.20", "202.106.46.151",  # ‰∏≠ÂõΩÁîµ‰ø°DNS
            # ÁæéÊ¥≤DNS
            "199.85.126.10", "199.85.127.10",  # Norton DNS
            "198.101.242.72", "23.253.163.53",  # Alternate DNS
            # ÂÖ∂‰ªñÂõΩÈôÖDNS
            "45.90.28.0", "45.90.30.0",  # NextDNS
            "185.228.168.9", "185.228.169.9",  # CleanBrowsing Family
            "76.76.19.61", "76.76.2.22"  # ControlD
        ]
        
        for dns_server in international_dns:
            try:
                resolver = dns.resolver.Resolver()
                resolver.nameservers = [dns_server]
                resolver.timeout = 1  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                resolver.lifetime = 1
                
                answers = resolver.resolve(self.domain, 'A')
                for answer in answers:
                    ip = str(answer)
                    if self._is_valid_ip(ip):
                        self.found_ips.add(ip)
                        print(f"‚úì ÂõΩÈôÖDNS {dns_server}: {ip}")
            except Exception:
                continue
    
    def _resolve_secure_dns(self):
        """ÂÆâÂÖ®DNSÊúçÂä°Âô®Ëß£Êûê"""
        secure_dns = [
            # Âä†ÂØÜDNSÊúçÂä°Âô®
            "9.9.9.9", "149.112.112.112",  # Quad9 (ÂÆâÂÖ®)
            "1.1.1.1", "1.0.0.1",  # Cloudflare (ÂÆâÂÖ®)
            "8.8.8.8", "8.8.4.4",  # Google (Áõ∏ÂØπÂÆâÂÖ®)
            "208.67.222.222", "208.67.220.220",  # OpenDNS (ÂÆâÂÖ®)
            # ÈöêÁßÅ‰øùÊä§DNS
            "94.140.14.14", "94.140.15.15",  # AdGuard (ÈöêÁßÅ)
            "76.76.19.61", "76.76.2.22",  # ControlD (ÈöêÁßÅ)
            "185.228.168.9", "185.228.169.9",  # CleanBrowsing (ÂÆâÂÖ®)
            "76.76.19.61", "76.76.2.22"  # ControlD (ÈöêÁßÅ)
        ]
        
        for dns_server in secure_dns:
            try:
                resolver = dns.resolver.Resolver()
                resolver.nameservers = [dns_server]
                resolver.timeout = 0.5  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥ÔºåÊèêÈ´òÈÄüÂ∫¶
                resolver.lifetime = 0.5
                
                answers = resolver.resolve(self.domain, 'A')
                for answer in answers:
                    ip = str(answer)
                    if self._is_valid_ip(ip):
                        self.found_ips.add(ip)
                        print(f"‚úì ÂÆâÂÖ®DNS {dns_server}: {ip}")
            except Exception:
                continue
    
    def _is_valid_ip(self, ip: str) -> bool:
        """Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÁöÑIPÂú∞ÂùÄ"""
        try:
            socket.inet_aton(ip)
            return True
        except socket.error:
            return False


class NetworkQuality:
    """ÁΩëÁªúË¥®ÈáèÂÆûÊó∂ËØÑ‰º∞"""
    
    def __init__(self):
        self.recent_latencies = []
        self.recent_errors = []
        self.max_history = 10
    
    def get_quality_factor(self) -> float:
        """ËøîÂõûÁΩëÁªúË¥®ÈáèÂõ†Â≠ê (0.5-2.0)"""
        if not self.recent_latencies:
            return 1.0
        
        avg_latency = sum(self.recent_latencies) / len(self.recent_latencies)
        error_rate = len(self.recent_errors) / max(len(self.recent_latencies), 1)
        
        # Âü∫‰∫éÂª∂ËøüÂíåÈîôËØØÁéáËÆ°ÁÆóË¥®ÈáèÂõ†Â≠ê
        if avg_latency < 50 and error_rate < 0.1:
            return 2.0  # ‰ºòÁßÄÁΩëÁªúÔºåÂèØ‰ª•È´òÂπ∂Âèë
        elif avg_latency < 100 and error_rate < 0.2:
            return 1.5  # ËâØÂ•ΩÁΩëÁªú
        elif avg_latency < 200 and error_rate < 0.3:
            return 1.0  # ‰∏ÄËà¨ÁΩëÁªú
        else:
            return 0.5  # ËæÉÂ∑ÆÁΩëÁªúÔºåÈôç‰ΩéÂπ∂Âèë
    
    def update_metrics(self, latency: float, success: bool):
        """Êõ¥Êñ∞ÁΩëÁªúË¥®ÈáèÊåáÊ†á"""
        self.recent_latencies.append(latency)
        if not success:
            self.recent_errors.append(time.time())
        
        # ‰øùÊåÅÂéÜÂè≤ËÆ∞ÂΩïÂú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
        if len(self.recent_latencies) > self.max_history:
            self.recent_latencies.pop(0)
        if len(self.recent_errors) > self.max_history:
            self.recent_errors.pop(0)


class AdaptiveConcurrencyManager:
    """Ëá™ÈÄÇÂ∫îÂπ∂ÂèëÁÆ°ÁêÜÂô® - Ê†πÊçÆÁΩëÁªúÁä∂ÂÜµÂä®ÊÄÅË∞ÉÊï¥Âπ∂ÂèëÊï∞"""
    
    def __init__(self):
        self.base_workers = 10  # Â¢ûÂä†Âü∫Á°ÄÂπ∂ÂèëÊï∞
        self.max_workers = 50   # Â¢ûÂä†ÊúÄÂ§ßÂπ∂ÂèëÊï∞
        self.network_quality = NetworkQuality()
        self.adaptive_mode = True
    
    def get_optimal_workers(self, total_ips: int) -> int:
        """Ê†πÊçÆÁΩëÁªúË¥®ÈáèÂíåIPÊï∞ÈáèÂä®ÊÄÅËÆ°ÁÆóÊúÄ‰ºòÂπ∂ÂèëÊï∞"""
        if not self.adaptive_mode:
            return min(self.base_workers, total_ips)
        
        # Ê†πÊçÆÁΩëÁªúË¥®ÈáèË∞ÉÊï¥Âü∫Á°ÄÂπ∂ÂèëÊï∞
        quality_factor = self.network_quality.get_quality_factor()
        adjusted_workers = int(self.base_workers * quality_factor)
        
        # Ê†πÊçÆIPÊï∞ÈáèË∞ÉÊï¥
        if total_ips <= 5:
            return min(3, total_ips)  # Â∞ëÈáèIPÊó∂Èôç‰ΩéÂπ∂Âèë
        elif total_ips <= 15:
            return min(adjusted_workers, total_ips)
        else:
            return min(self.max_workers, total_ips)


class OptimizedConnectionManager:
    """‰ºòÂåñÁöÑËøûÊé•ÁÆ°ÁêÜÂô®"""
    
    def __init__(self, config=None):
        self.config = config or {}
        self.session_pool = {}
        self.connection_pool = None
        self.setup_connection_pool()
    
    def setup_connection_pool(self):
        """ËÆæÁΩÆËøûÊé•Ê±†"""
        # ‰ªéÈÖçÁΩÆËé∑ÂèñÂèÇÊï∞
        retry_attempts = self.config.get("retry_attempts", 2)
        pool_size = self.config.get("connection_pool_size", 20)
        
        # ÂàõÂª∫‰ºòÂåñÁöÑ HTTP ÈÄÇÈÖçÂô®
        retry_strategy = Retry(
            total=retry_attempts,  # ‰ªéÈÖçÁΩÆËé∑ÂèñÈáçËØïÊ¨°Êï∞
            backoff_factor=0.1,  # Âø´ÈÄüÈáçËØï
            status_forcelist=[429, 500, 502, 503, 504],
        )
        
        self.connection_pool = HTTPAdapter(
            pool_connections=pool_size,  # ‰ªéÈÖçÁΩÆËé∑ÂèñËøûÊé•Ê±†Â§ßÂ∞è
            pool_maxsize=pool_size,
            max_retries=retry_strategy,
            pool_block=False  # ÈùûÈòªÂ°ûÊ®°Âºè
        )
    
    def get_session(self, ip: str) -> requests.Session:
        """Ëé∑ÂèñÊàñÂàõÂª∫‰ºöËØù"""
        if ip not in self.session_pool:
            session = requests.Session()
            session.mount("http://", self.connection_pool)
            session.mount("https://", self.connection_pool)
            
            # ‰ºòÂåñ‰ºöËØùÈÖçÁΩÆ
            session.headers.update({
                'User-Agent': 'HostsOptimizer/1.0',
                'Connection': 'keep-alive',
                'Accept-Encoding': 'gzip, deflate'
            })
            
            self.session_pool[ip] = session
        
        return self.session_pool[ip]
    
    def cleanup(self):
        """Ê∏ÖÁêÜËøûÊé•Ê±†"""
        for session in self.session_pool.values():
            session.close()
        self.session_pool.clear()


class MultiDimensionalHealthChecker:
    """Â§öÁª¥Â∫¶ÂÅ•Â∫∑Ê£ÄÊµãÂô®"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.test_iterations = config.get("health_test_iterations", 3)
        self.stability_threshold = config.get("stability_threshold", 0.8)
        
    def check_connection_stability(self, ip: str, port: int = 443) -> Dict:
        """Ê£ÄÊü•ËøûÊé•Á®≥ÂÆöÊÄß"""
        results = {
            'success_rate': 0.0,
            'avg_latency': 0.0,
            'latency_std': 0.0,
            'stability_score': 0.0,
            'connection_errors': []
        }
        
        latencies = []
        success_count = 0
        
        for i in range(self.test_iterations):
            try:
                start_time = time.time()
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect((ip, port))
                sock.close()
                end_time = time.time()
                
                latency = (end_time - start_time) * 1000
                latencies.append(latency)
                success_count += 1
                
            except Exception as e:
                results['connection_errors'].append(str(e))
            
            time.sleep(0.1)  # Áü≠ÊöÇÈó¥Èöî
        
        if latencies:
            results['success_rate'] = success_count / self.test_iterations
            results['avg_latency'] = statistics.mean(latencies)
            results['latency_std'] = statistics.stdev(latencies) if len(latencies) > 1 else 0
            results['stability_score'] = min(1.0, results['success_rate'] * (1 - results['latency_std'] / results['avg_latency']))
        
        return results
    
    
    def check_ssl_quality(self, ip: str, domain: str) -> Dict:
        """Ê£ÄÊü•SSLËØÅ‰π¶Ë¥®Èáè"""
        results = {
            'cert_score': 0.0,
            'cert_validity_days': 0,
            'cert_issuer': '',
            'cert_algorithm': '',
            'cert_strength': '',
            'ssl_grade': 'F'
        }
        
        try:
            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED
            
            with socket.create_connection((ip, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=domain) as ssock:
                    cert = ssock.getpeercert()
                    
                    # ËØÅ‰π¶ÊúâÊïàÊúü
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (not_after - datetime.now()).days
                    results['cert_validity_days'] = days_until_expiry
                    
                    # ËØÅ‰π¶È¢ÅÂèëËÄÖ
                    issuer = cert.get('issuer', [])
                    for item in issuer:
                        if item[0][0] == 'organizationName':
                            results['cert_issuer'] = item[0][1]
                            break
                    
                    # ËØÅ‰π¶ÁÆóÊ≥ïÂíåÂº∫Â∫¶
                    cipher = ssock.cipher()
                    if cipher:
                        results['cert_algorithm'] = cipher[0]
                        results['cert_strength'] = str(cipher[2])
                    
                    # ËÆ°ÁÆóËØÅ‰π¶ËØÑÂàÜ
                    cert_score = 0
                    if days_until_expiry > 30:
                        cert_score += 30
                    elif days_until_expiry > 7:
                        cert_score += 20
                    else:
                        cert_score += 10
                    
                    if 'Let\'s Encrypt' in results['cert_issuer'] or 'DigiCert' in results['cert_issuer']:
                        cert_score += 20
                    
                    if 'AES' in results['cert_algorithm'] or 'ChaCha20' in results['cert_algorithm']:
                        cert_score += 20
                    
                    if int(results['cert_strength']) >= 256:
                        cert_score += 30
                    elif int(results['cert_strength']) >= 128:
                        cert_score += 20
                    
                    results['cert_score'] = min(100, cert_score)
                    
                    # SSLÁ≠âÁ∫ß
                    if results['cert_score'] >= 90:
                        results['ssl_grade'] = 'A+'
                    elif results['cert_score'] >= 80:
                        results['ssl_grade'] = 'A'
                    elif results['cert_score'] >= 70:
                        results['ssl_grade'] = 'B'
                    elif results['cert_score'] >= 60:
                        results['ssl_grade'] = 'C'
                    elif results['cert_score'] >= 50:
                        results['ssl_grade'] = 'D'
                    else:
                        results['ssl_grade'] = 'F'
        
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def check_protocol_support(self, ip: str, domain: str) -> Dict:
        """Ê£ÄÊü•ÂçèËÆÆÊîØÊåÅ"""
        results = {
            'http_support': False,
            'https_support': False,
            'http2_support': False,  # ‰øùÁïôÂ≠óÊÆµ‰ΩÜ‰∏çÂÜçÊ£ÄÊµã
            'http3_support': False,
            'protocol_score': 0.0
        }
        
        # HTTPÊîØÊåÅ
        try:
            response = requests.get(f"http://{ip}/", headers={'Host': domain}, timeout=5)
            results['http_support'] = response.status_code in [200, 301, 302, 403]
        except:
            pass
        
        # HTTPSÊîØÊåÅ
        try:
            response = requests.get(f"https://{ip}/", headers={'Host': domain}, timeout=5, verify=False)
            results['https_support'] = response.status_code in [200, 301, 302, 403]
        except:
            pass
        
        # HTTP/2ÊîØÊåÅÊ£ÄÊµãÂ∑≤ÂèñÊ∂à
        # ‰∏çÂÜçËøõË°åHTTP/2Ê£ÄÊµã‰ª•ÊèêÈ´òÊÄßËÉΩ
        
        # ËÆ°ÁÆóÂçèËÆÆËØÑÂàÜ
        protocol_score = 0
        if results['http_support']:
            protocol_score += 25
        if results['https_support']:
            protocol_score += 50
        # HTTP/2ËØÑÂàÜÂ∑≤ÁßªÈô§
        
        results['protocol_score'] = protocol_score
        return results
    
    def check_geographic_performance(self, ip: str) -> Dict:
        """Ê£ÄÊü•Âú∞ÁêÜ‰ΩçÁΩÆÊÄßËÉΩÔºàÂü∫‰∫éIPÊÆµÊé®Êñ≠Ôºâ"""
        results = {
            'region': 'Unknown',
            'provider': 'Unknown',
            'geo_score': 0.0
        }
        
        # ÁÆÄÂåñÁöÑÂú∞ÁêÜ‰ΩçÁΩÆÊ£ÄÊµãÔºàÂü∫‰∫éIPÊÆµÔºâ
        try:
            # ËøôÈáåÂèØ‰ª•ÈõÜÊàêIPÂú∞ÁêÜ‰ΩçÁΩÆAPIÔºåÁé∞Âú®‰ΩøÁî®ÁÆÄÂåñÁâàÊú¨
            first_octet = int(ip.split('.')[0])
            
            if 1 <= first_octet <= 126:
                results['region'] = 'Class A'
            elif 128 <= first_octet <= 191:
                results['region'] = 'Class B'
            elif 192 <= first_octet <= 223:
                results['region'] = 'Class C'
            else:
                results['region'] = 'Other'
            
            # Âü∫‰∫éIPÊÆµÊé®Êñ≠Êèê‰æõÂïÜ
            if ip.startswith('89.187'):
                results['provider'] = 'BIS Studio CDN'
                results['geo_score'] = 0.9
            elif ip.startswith('143.244'):
                results['provider'] = 'Cloud Provider'
                results['geo_score'] = 0.8
            else:
                results['geo_score'] = 0.5
                
        except:
            pass
        
        return results
    
    def comprehensive_health_check(self, ip: str, domain: str) -> Dict:
        """ÁªºÂêàÂÅ•Â∫∑Ê£ÄÊü•"""
        health_results = {
            'ip': ip,
            'overall_health_score': 0.0,
            'stability': {},
            'bandwidth': {},
            'ssl_quality': {},
            'protocol_support': {},
            'geographic': {},
            'health_grade': 'F'
        }
        
        # Âπ∂Ë°åÊâßË°åÂêÑÈ°πÊ£ÄÊü•
        futures = {}
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures['stability'] = executor.submit(self.check_connection_stability, ip)
            futures['ssl_quality'] = executor.submit(self.check_ssl_quality, ip, domain)
            futures['protocol_support'] = executor.submit(self.check_protocol_support, ip, domain)
            futures['geographic'] = executor.submit(self.check_geographic_performance, ip)
            
            
            for key, future in futures.items():
                try:
                    health_results[key] = future.result(timeout=5)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                except Exception as e:
                    health_results[key] = {'error': str(e)}
        
        # ËÆ°ÁÆóÁªºÂêàÂÅ•Â∫∑ËØÑÂàÜ
        scores = []
        
        # Á®≥ÂÆöÊÄßËØÑÂàÜ (40%)
        if 'stability_score' in health_results['stability']:
            scores.append(health_results['stability']['stability_score'] * 0.4)
        
        # SSLË¥®ÈáèËØÑÂàÜ (30%)
        if 'cert_score' in health_results['ssl_quality']:
            scores.append(health_results['ssl_quality']['cert_score'] / 100 * 0.3)
        
        # ÂçèËÆÆÊîØÊåÅËØÑÂàÜ (20%)
        if 'protocol_score' in health_results['protocol_support']:
            scores.append(health_results['protocol_support']['protocol_score'] / 100 * 0.2)
        
        # Âú∞ÁêÜ‰ΩçÁΩÆËØÑÂàÜ (10%)
        if 'geo_score' in health_results['geographic']:
            scores.append(health_results['geographic']['geo_score'] * 0.1)
        
        if scores:
            health_results['overall_health_score'] = sum(scores) * 100
            
            # ÂÅ•Â∫∑Á≠âÁ∫ß
            if health_results['overall_health_score'] >= 90:
                health_results['health_grade'] = 'A+'
            elif health_results['overall_health_score'] >= 80:
                health_results['health_grade'] = 'A'
            elif health_results['overall_health_score'] >= 70:
                health_results['health_grade'] = 'B'
            elif health_results['overall_health_score'] >= 60:
                health_results['health_grade'] = 'C'
            elif health_results['overall_health_score'] >= 50:
                health_results['health_grade'] = 'D'
            else:
                health_results['health_grade'] = 'F'
        
        return health_results


class SSLCertificateChecker:
    """SSLËØÅ‰π¶Ê£ÄÊü•Âô® - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂüüÂêçËøõË°åËØÅ‰π¶È™åËØÅ"""
    
    def __init__(self):
        # ÂàõÂª∫Ê†áÂáÜÁöÑSSL‰∏ä‰∏ãÊñá
        self.ssl_context = ssl.create_default_context()
        self.ssl_context.check_hostname = True  # Ê£ÄÊü•‰∏ªÊú∫Âêç
        self.ssl_context.verify_mode = ssl.CERT_REQUIRED  # È™åËØÅËØÅ‰π¶
    
    def check_ssl_certificate(self, ip: str, hostname: str = "ar-gcp-cdn.bistudio.com") -> Dict:
        """Ê£ÄÊü•SSLËØÅ‰π¶ÊúâÊïàÊÄß - ‰ΩøÁî®ÂüüÂêçËøõË°åÈ™åËØÅ"""
        try:
            # ÂàõÂª∫Âà∞IPÁöÑTCPËøûÊé•
            sock = socket.create_connection((ip, 443), timeout=5)
            
            # ‰ΩøÁî®ÂüüÂêçËøõË°åSSLÊè°ÊâãÂíåËØÅ‰π¶È™åËØÅ
            ssock = self.ssl_context.wrap_socket(sock, server_hostname=hostname)
            
            # Ëé∑ÂèñËØÅ‰π¶‰ø°ÊÅØ
            cert = ssock.getpeercert()
            
            # Ëß£ÊûêËØÅ‰π¶‰ø°ÊÅØ
            cert_info = {
                'valid': True,
                'ssl_available': True,
                'connection_successful': True,
                'certificate_valid': True,
                'hostname_verified': True
            }
            
            if cert:
                cert_info.update({
                    'subject': dict(x[0] for x in cert['subject']) if cert.get('subject') else {},
                    'issuer': dict(x[0] for x in cert['issuer']) if cert.get('issuer') else {},
                    'not_before': cert.get('notBefore', 'Unknown'),
                    'not_after': cert.get('notAfter', 'Unknown'),
                    'serial_number': cert.get('serialNumber', 'Unknown'),
                    'version': cert.get('version', 'Unknown'),
                    'signature_algorithm': cert.get('signatureAlgorithm', 'Unknown'),
                    'days_until_expiry': self._calculate_days_until_expiry(cert.get('notAfter', ''))
                })
                
                # Ê£ÄÊü•ËØÅ‰π¶ÊòØÂê¶ÂåÖÂê´Ê≠£Á°ÆÁöÑÂüüÂêç
                if 'subjectAltName' in cert:
                    san_list = cert['subjectAltName']
                    domain_found = False
                    for san_type, san_value in san_list:
                        if san_type == 'DNS' and (hostname in san_value or san_value in hostname):
                            domain_found = True
                            break
                    cert_info['domain_match'] = domain_found
                else:
                    # Ê£ÄÊü•subject‰∏≠ÁöÑCN
                    subject = cert_info.get('subject', {})
                    cn = subject.get('commonName', '')
                    cert_info['domain_match'] = hostname in cn or cn in hostname
            
            ssock.close()
            return cert_info
            
        except ssl.SSLError as e:
            error_msg = str(e)
            # ÂàÜÊûêÂÖ∑‰ΩìÁöÑSSLÈîôËØØ
            if "certificate verify failed" in error_msg.lower():
                return {
                    'valid': False,
                    'ssl_available': True,  # SSLËøûÊé•ÂèØÁî®
                    'connection_successful': True,
                    'certificate_valid': False,
                    'hostname_verified': False,
                    'error': "ËØÅ‰π¶È™åËØÅÂ§±Ë¥•",
                    'error_type': 'CERT_VERIFY_FAILED',
                    'certificate_warning': 'ËØÅ‰π¶È™åËØÅÂ§±Ë¥•ÔºåÂèØËÉΩÊòØËØÅ‰π¶‰∏çÂåπÈÖçÊàñËøáÊúü'
                }
            elif "hostname doesn't match" in error_msg.lower():
                return {
                    'valid': False,
                    'ssl_available': True,
                    'connection_successful': True,
                    'certificate_valid': True,
                    'hostname_verified': False,
                    'error': "‰∏ªÊú∫Âêç‰∏çÂåπÈÖç",
                    'error_type': 'HOSTNAME_MISMATCH',
                    'certificate_warning': 'ËØÅ‰π¶ÊúâÊïà‰ΩÜ‰∏ªÊú∫Âêç‰∏çÂåπÈÖç'
                }
            else:
                return {
                    'valid': False,
                    'ssl_available': False,
                    'connection_successful': False,
                    'certificate_valid': False,
                    'hostname_verified': False,
                    'error': f"SSLÈîôËØØ: {error_msg[:50]}",
                    'error_type': 'SSL_ERROR'
                }
        except socket.timeout:
            return {
                'valid': False,
                'ssl_available': False,
                'connection_successful': False,
                'certificate_valid': False,
                'hostname_verified': False,
                'error': "ËøûÊé•Ë∂ÖÊó∂",
                'error_type': 'TIMEOUT'
            }
        except Exception as e:
            return {
                'valid': False,
                'ssl_available': False,
                'connection_successful': False,
                'certificate_valid': False,
                'hostname_verified': False,
                'error': f"ËøûÊé•ÈîôËØØ: {str(e)[:50]}",
                'error_type': 'CONNECTION_ERROR'
            }
    
    def _calculate_days_until_expiry(self, not_after: str) -> int:
        """ËÆ°ÁÆóËØÅ‰π¶Âà∞ÊúüÂ§©Êï∞"""
        if not not_after:
            return -1
        try:
            # Â∞ùËØïÂ§öÁßçÊó•ÊúüÊ†ºÂºè
            formats = [
                '%b %d %H:%M:%S %Y %Z',
                '%b %d %H:%M:%S %Y',
                '%Y-%m-%d %H:%M:%S'
            ]
            
            for fmt in formats:
                try:
                    expiry_date = datetime.strptime(not_after, fmt)
                    days_left = (expiry_date - datetime.now()).days
                    return max(0, days_left)
                except ValueError:
                    continue
            
            return -1
        except:
            return -1


class OptimizedTester:
    """‰ºòÂåñÁöÑÊµãËØïÂô®"""
    
    def __init__(self, config):
        self.config = config
        self.connection_manager = OptimizedConnectionManager(config)
        self.network_quality = NetworkQuality()
        self.concurrency_manager = AdaptiveConcurrencyManager()
        self.ssl_checker = SSLCertificateChecker()
        self.health_checker = MultiDimensionalHealthChecker(config)
        
        # Ê†πÊçÆÈÖçÁΩÆË∞ÉÊï¥ËÆæÁΩÆ
        if config.get("fast_mode", True):
            self.concurrency_manager.adaptive_mode = config.get("adaptive_concurrency", True)
        else:
            self.concurrency_manager.adaptive_mode = False
    
    def test_ips_optimized(self, ips: List[str], progress_callback=None) -> List[Dict]:
        """‰ºòÂåñÁöÑIPÊµãËØï"""
        if not ips:
            return []
        
        # Âä®ÊÄÅË∞ÉÊï¥Âπ∂ÂèëÊï∞
        max_workers = self.concurrency_manager.get_optimal_workers(len(ips))
        
        print(f"‰ΩøÁî® {max_workers} ‰∏™Âπ∂ÂèëÁ∫øÁ®ãÊµãËØï {len(ips)} ‰∏™IPÂú∞ÂùÄ")
        
        results = []
        completed_count = 0
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            # Êèê‰∫§ÊµãËØï‰ªªÂä°
            futures = {}
            for ip in ips:
                # ÂêåÊó∂Êèê‰∫§pingÂíåHTTPÊµãËØï
                ping_future = executor.submit(self._ping_ip_fast, ip)
                http_future = executor.submit(self._test_http_fast, ip)
                futures[ip] = (ping_future, http_future)
            
            # Êî∂ÈõÜÁªìÊûú
            for ip, (ping_future, http_future) in futures.items():
                try:
                    # Ëé∑ÂèñpingÁªìÊûú
                    _, ping_latency, ping_success = ping_future.result(timeout=5)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                    
                    # Êõ¥Êñ∞ÁΩëÁªúË¥®ÈáèÊåáÊ†á
                    self.network_quality.update_metrics(ping_latency, ping_success)
                    
                    # Ëé∑ÂèñHTTPÊµãËØïÁªìÊûú
                    _, http_results = http_future.result(timeout=8)  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                    
                    # Â¶ÇÊûúÂêØÁî®Â§öÁª¥Â∫¶ÂÅ•Â∫∑Ê£ÄÊµãÔºåËøõË°åÁªºÂêàÂÅ•Â∫∑Ê£ÄÊü•
                    health_info = None
                    if self.config.get("multi_dimensional_health", True):
                        health_info = self.health_checker.comprehensive_health_check(ip, self.config.get("domain", "ar-gcp-cdn.bistudio.com"))
                        
                        # Ê†πÊçÆÂÅ•Â∫∑ËØÑÂàÜË∞ÉÊï¥ÊÄª‰ΩìËØÑÂàÜ
                        if health_info.get('overall_health_score', 0) > 0:
                            # ÂÅ•Â∫∑ËØÑÂàÜ‰Ωú‰∏∫È¢ùÂ§ñÂ•ñÂä±
                            health_bonus = health_info['overall_health_score'] * 0.5  # ÂÅ•Â∫∑ËØÑÂàÜ50%‰Ωú‰∏∫Â•ñÂä±
                            http_results['overall_score'] += health_bonus
                    
                    # Â¶ÇÊûúHTTPSÂèØÁî®‰∏îÂêØÁî®SSLÊ£ÄÊü•ÔºåÊ£ÄÊü•SSLËØÅ‰π¶
                    ssl_cert_info = None
                    if http_results['https_available'] and self.config.get("ssl_check_enabled", True):
                        ssl_cert_info = self.ssl_checker.check_ssl_certificate(ip, self.config.get("domain", "ar-gcp-cdn.bistudio.com"))
                        
                        # Ê†πÊçÆSSLËØÅ‰π¶Áä∂ÊÄÅË∞ÉÊï¥ËØÑÂàÜ
                        if not ssl_cert_info.get('ssl_available', False):
                            # SSLËøûÊé•‰∏çÂèØÁî®ÔºåÂ§ßÂπÖÈôç‰ΩéËØÑÂàÜ
                            http_results['overall_score'] = max(0, http_results['overall_score'] - 20)
                        elif not ssl_cert_info.get('certificate_valid', False):
                            # ËØÅ‰π¶Êó†ÊïàÔºåÈôç‰ΩéËØÑÂàÜ
                            http_results['overall_score'] = max(0, http_results['overall_score'] - 15)
                        elif not ssl_cert_info.get('hostname_verified', False):
                            # ‰∏ªÊú∫Âêç‰∏çÂåπÈÖçÔºåËΩªÂæÆÈôç‰ΩéËØÑÂàÜ
                            http_results['overall_score'] = max(0, http_results['overall_score'] - 10)
                        elif ssl_cert_info.get('certificate_warning'):
                            # ÊúâËØÅ‰π¶Ë≠¶ÂëäÔºåËΩªÂæÆÈôç‰ΩéËØÑÂàÜ
                            http_results['overall_score'] = max(0, http_results['overall_score'] - 5)
                    
                    # ÂêàÂπ∂ÁªìÊûú
                    result = {
                        'ip': ip,
                        'ping_latency': ping_latency,
                        'ping_success': ping_success,
                        'http_available': http_results['http_available'],
                        'https_available': http_results['https_available'],
                        'best_http_latency': http_results['best_http_latency'],
                        'best_https_latency': http_results['best_https_latency'],
                        'overall_score': http_results['overall_score'],
                        'http_status': http_results['http_status'],
                        'https_status': http_results['https_status'],
                        'ssl_certificate': ssl_cert_info,
                        'health_info': health_info
                    }
                    
                    results.append(result)
                    completed_count += 1
                    
                    # Ë∞ÉÁî®ËøõÂ∫¶ÂõûË∞É
                    if progress_callback:
                        progress_callback(completed_count, len(ips), f"Â∑≤ÊµãËØï {completed_count}/{len(ips)} ‰∏™IP")
                    
                    # ÂÆûÊó∂ÊòæÁ§∫ÁªìÊûú
                    self._display_result(result)
                    
                except Exception as e:
                    print(f"‚úó {ip:15s} - ÊµãËØïÂºÇÂ∏∏: {e}")
                    results.append(self._create_failed_result(ip))
                    completed_count += 1
                    
                    # Âç≥‰ΩøÂ§±Ë¥•‰πüË¶ÅÊõ¥Êñ∞ËøõÂ∫¶
                    if progress_callback:
                        progress_callback(completed_count, len(ips), f"Â∑≤ÊµãËØï {completed_count}/{len(ips)} ‰∏™IP")
        
        # Ê∏ÖÁêÜËøûÊé•Ê±†
        self.connection_manager.cleanup()
        
        # ÊåâËØÑÂàÜÊéíÂ∫è
        results.sort(key=lambda x: (-x['overall_score'], x['best_https_latency'], x['best_http_latency']))
        return results
    
    def _ping_ip_fast(self, ip: str) -> Tuple[str, float, bool]:
        """Âø´ÈÄüpingÊµãËØï"""
        try:
            start_time = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.config["test_timeout"])
            result = sock.connect_ex((ip, 80))
            end_time = time.time()
            sock.close()
            
            if result == 0:
                latency = (end_time - start_time) * 1000
                return ip, latency, True
            else:
                return ip, float('inf'), False
        except Exception:
            return ip, float('inf'), False
    
    def _test_http_fast(self, ip: str) -> Tuple[str, Dict]:
        """Âø´ÈÄüHTTPÊµãËØï"""
        results = {
            'ip': ip,
            'http_status': {},
            'https_status': {},
            'best_http_latency': float('inf'),
            'best_https_latency': float('inf'),
            'http_available': False,
            'https_available': False,
            'overall_score': 0
        }
        
        session = self.connection_manager.get_session(ip)
        
        # Âè™ÊµãËØïÊ†πË∑ØÂæÑÔºåÂáèÂ∞ëÊµãËØïÊó∂Èó¥
        test_paths = ["/"]  # Âø´ÈÄüÊ®°ÂºèÂè™ÊµãËØïÊ†πË∑ØÂæÑ
        
        # ÊµãËØïHTTP
        if self.config.get("test_http", True):
            for path in test_paths:
                url = f"http://{ip}{path}"
                try:
                    start_time = time.time()
                    response = session.get(
                        url, 
                        timeout=self.config.get("http_timeout", 8),  # ÂáèÂ∞ëË∂ÖÊó∂Êó∂Èó¥
                        headers={'Host': 'ar-gcp-cdn.bistudio.com'},
                        allow_redirects=True,
                        stream=False
                    )
                    end_time = time.time()
                    latency = (end_time - start_time) * 1000
                    
                    status_code = response.status_code
                    is_success = (200 <= status_code < 300) or (status_code == 403)
                    
                    results['http_status'][path] = {
                        'status_code': status_code,
                        'latency': latency,
                        'success': is_success
                    }
                    
                    if is_success and latency < results['best_http_latency']:
                        results['best_http_latency'] = latency
                        results['http_available'] = True
                        
                except Exception as e:
                    results['http_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': str(e)[:50]
                    }
        
        # ÊµãËØïHTTPS
        if self.config.get("test_https", True):
            for path in test_paths:
                url = f"https://{ip}{path}"
                try:
                    start_time = time.time()
                    
                    # Êô∫ËÉΩSSLÂ§ÑÁêÜÔºöÂÖàÂ∞ùËØï‰∏•Ê†ºÈ™åËØÅÔºåÂ§±Ë¥•Êó∂Êèê‰æõËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØ
                    verify_ssl = self.config.get("verify_ssl", True)
                    response = session.get(
                        url, 
                        timeout=self.config.get("http_timeout", 8),
                        headers={'Host': 'ar-gcp-cdn.bistudio.com'},
                        allow_redirects=True,
                        verify=verify_ssl,
                        stream=False
                    )
                    end_time = time.time()
                    latency = (end_time - start_time) * 1000
                    
                    status_code = response.status_code
                    is_success = (200 <= status_code < 300) or (status_code == 403)
                    
                    results['https_status'][path] = {
                        'status_code': status_code,
                        'latency': latency,
                        'success': is_success,
                        'ssl_verified': verify_ssl
                    }
                    
                    if is_success and latency < results['best_https_latency']:
                        results['best_https_latency'] = latency
                        results['https_available'] = True
                        
                except requests.exceptions.SSLError as e:
                    # SSLÈ™åËØÅÂ§±Ë¥•ÔºåÂ∞ùËØï‰∏çÈ™åËØÅSSLÔºàÂ¶ÇÊûúÈÖçÁΩÆÂÖÅËÆ∏Ôºâ
                    if verify_ssl and self.config.get("fallback_to_unverified_ssl", True):
                        try:
                            start_time = time.time()
                            response = session.get(
                                url, 
                                timeout=self.config.get("http_timeout", 8),
                                headers={'Host': 'ar-gcp-cdn.bistudio.com'},
                                allow_redirects=True,
                                verify=False,  # ‰∏çÈ™åËØÅSSL
                                stream=False
                            )
                            end_time = time.time()
                            latency = (end_time - start_time) * 1000
                            
                            status_code = response.status_code
                            is_success = (200 <= status_code < 300) or (status_code == 403)
                            
                            results['https_status'][path] = {
                                'status_code': status_code,
                                'latency': latency,
                                'success': is_success,
                                'ssl_verified': False,
                                'ssl_warning': f"SSLÈ™åËØÅÂ§±Ë¥•‰ΩÜËøûÊé•ÂèØÁî®: {str(e)[:30]}"
                            }
                            
                            if is_success and latency < results['best_https_latency']:
                                results['best_https_latency'] = latency
                                results['https_available'] = True
                                
                        except Exception as e2:
                            # Âç≥‰Ωø‰∏çÈ™åËØÅSSL‰πüÂ§±Ë¥•
                            results['https_status'][path] = {
                                'status_code': 0,
                                'latency': float('inf'),
                                'success': False,
                                'error': f"SSLËøûÊé•Â§±Ë¥•: {str(e2)[:50]}",
                                'ssl_verified': False
                            }
                    else:
                        # Â∑≤ÁªèÊòØ‰∏çÈ™åËØÅSSLÔºåÁõ¥Êé•ËÆ∞ÂΩïÈîôËØØ
                        results['https_status'][path] = {
                            'status_code': 0,
                            'latency': float('inf'),
                            'success': False,
                            'error': f"SSLÈîôËØØ: {str(e)[:50]}",
                            'ssl_verified': False
                        }
                except Exception as e:
                    results['https_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': str(e)[:50],
                        'ssl_verified': verify_ssl
                    }
        
        # ËÆ°ÁÆóËØÑÂàÜ - ‰ºòÂåñÁâàÊú¨ÔºåÊèê‰æõÊõ¥Â§ßÂ∑ÆÂºÇ
        score = 0
        
        # Ëé∑ÂèñËØÑÂàÜÊùÉÈáçÈÖçÁΩÆ
        weights = self.config.get("scoring_weights", {
            "http_base": 50,
            "https_base": 80,
            "ping_base": 20,
            "protocol_complete_bonus": 30
        })
        
        # Âü∫Á°ÄËøûÊé•ÂàÜÊï∞
        if results['http_available']:
            score += weights["http_base"]  # HTTPÂü∫Á°ÄÂàÜ
            # HTTPÂª∂ËøüÂ•ñÂä±ÂàÜ
            if results['best_http_latency'] < 50:
                score += 30
            elif results['best_http_latency'] < 100:
                score += 25
            elif results['best_http_latency'] < 200:
                score += 20
            elif results['best_http_latency'] < 500:
                score += 15
            elif results['best_http_latency'] < 1000:
                score += 10
            else:
                score += 5
        
        if results['https_available']:
            score += weights["https_base"]  # HTTPSÂü∫Á°ÄÂàÜÔºàÊõ¥È´òÊùÉÈáçÔºâ
            # HTTPSÂª∂ËøüÂ•ñÂä±ÂàÜ
            if results['best_https_latency'] < 50:
                score += 40
            elif results['best_https_latency'] < 100:
                score += 35
            elif results['best_https_latency'] < 200:
                score += 30
            elif results['best_https_latency'] < 500:
                score += 25
            elif results['best_https_latency'] < 1000:
                score += 20
            else:
                score += 10
        
        # PingÂª∂ËøüÂü∫Á°ÄÂàÜÔºàÂç≥‰ΩøÊ≤°ÊúâHTTP/HTTPS‰πüÊúâÂàÜÊï∞Ôºâ
        if results.get('ping_success', False):
            ping_latency = results.get('ping_latency', float('inf'))
            if ping_latency < 50:
                score += weights["ping_base"]
            elif ping_latency < 100:
                score += int(weights["ping_base"] * 0.75)
            elif ping_latency < 200:
                score += int(weights["ping_base"] * 0.5)
            elif ping_latency < 500:
                score += int(weights["ping_base"] * 0.25)
            else:
                score += int(weights["ping_base"] * 0.1)
        
        # ÂçèËÆÆÂÆåÊï¥ÊÄßÂ•ñÂä±
        if results['http_available'] and results['https_available']:
            score += weights["protocol_complete_bonus"]  # ÂêåÊó∂ÊîØÊåÅHTTPÂíåHTTPSÁöÑÂ•ñÂä±
        
        results['overall_score'] = score
        return ip, results
    
    def _display_result(self, result: Dict):
        """ÂÆûÊó∂ÊòæÁ§∫ÊµãËØïÁªìÊûú"""
        status_parts = []
        if result['ping_success']:
            status_parts.append(f"Ping: {result['ping_latency']:.1f}ms")
        else:
            status_parts.append("Ping: Â§±Ë¥•")
        
        if result['http_available']:
            status_parts.append(f"HTTP: {result['best_http_latency']:.1f}ms")
        if result['https_available']:
            https_info = f"HTTPS: {result['best_https_latency']:.1f}ms"
            
            # Ê£ÄÊü•HTTPSÁä∂ÊÄÅ‰∏≠ÁöÑSSL‰ø°ÊÅØ
            ssl_warning = None
            ssl_verified = True
            
            # ‰ªéHTTPSÁä∂ÊÄÅ‰∏≠Ëé∑ÂèñSSL‰ø°ÊÅØ
            for path, status in result.get('https_status', {}).items():
                if status.get('success', False):
                    if not status.get('ssl_verified', True):
                        ssl_verified = False
                        ssl_warning = status.get('ssl_warning', 'SSLÈ™åËØÅÂ§±Ë¥•')
                    break
            
            # Ê∑ªÂä†SSLËØÅ‰π¶Áä∂ÊÄÅ
            if result.get('ssl_certificate'):
                ssl_cert = result['ssl_certificate']
                if ssl_cert.get('ssl_available', False):
                    if ssl_cert.get('certificate_valid', False) and ssl_cert.get('hostname_verified', False):
                        # ËØÅ‰π¶ÊúâÊïà‰∏î‰∏ªÊú∫ÂêçÂåπÈÖç
                        days_left = ssl_cert.get('days_until_expiry', -1)
                        if days_left > 30:
                            https_info += " (SSL‚úì)"
                        elif days_left > 0:
                            https_info += f" (SSL‚ö†{days_left}d)"
                        else:
                            https_info += " (SSL‚ö†ËøáÊúü)"
                    elif ssl_cert.get('certificate_valid', False):
                        # ËØÅ‰π¶ÊúâÊïà‰ΩÜ‰∏ªÊú∫Âêç‰∏çÂåπÈÖç
                        https_info += " (SSL‚ö†‰∏ªÊú∫Âêç)"
                    else:
                        # ËØÅ‰π¶Êó†Êïà
                        https_info += " (SSL‚ö†ËØÅ‰π¶)"
                else:
                    # SSLËøûÊé•‰∏çÂèØÁî®
                    https_info += " (SSL‚úó)"
            elif not ssl_verified:
                # Âü∫‰∫éHTTPSÊµãËØïÁªìÊûúÁöÑSSLÁä∂ÊÄÅ
                https_info += " (SSL‚ö†)"
            else:
                # ÈªòËÆ§SSLÁä∂ÊÄÅ
                https_info += " (SSL‚úì)"
                
            status_parts.append(https_info)
        
        # Ê∑ªÂä†ËØÑÂàÜÁ≠âÁ∫ßÊòæÁ§∫
        score = result['overall_score']
        if score >= 200:
            score_display = f"ËØÑÂàÜ: {score} (‰ºòÁßÄ)"
        elif score >= 150:
            score_display = f"ËØÑÂàÜ: {score} (ËâØÂ•Ω)"
        elif score >= 100:
            score_display = f"ËØÑÂàÜ: {score} (‰∏ÄËà¨)"
        elif score >= 50:
            score_display = f"ËØÑÂàÜ: {score} (ËæÉÂ∑Æ)"
        else:
            score_display = f"ËØÑÂàÜ: {score} (ÂæàÂ∑Æ)"
        
        status_parts.append(score_display)
        
        # Ê∑ªÂä†ÂÅ•Â∫∑Ê£ÄÊµã‰ø°ÊÅØ
        if result.get('health_info') and result['health_info'].get('overall_health_score', 0) > 0:
            health_score = result['health_info']['overall_health_score']
            health_grade = result['health_info'].get('health_grade', 'F')
            status_parts.append(f"ÂÅ•Â∫∑: {health_score:.1f} ({health_grade})")
        
        print(f"‚úì {result['ip']:15s} - {' | '.join(status_parts)}")
    
    def _create_failed_result(self, ip: str) -> Dict:
        """ÂàõÂª∫Â§±Ë¥•ÁªìÊûú"""
        return {
            'ip': ip,
            'ping_latency': float('inf'),
            'ping_success': False,
            'http_available': False,
            'https_available': False,
            'best_http_latency': float('inf'),
            'best_https_latency': float('inf'),
            'overall_score': 0,
            'http_status': {},
            'https_status': {},
            'ssl_certificate': None
        }


class HostsOptimizer:
    """Hosts ÈÄâ‰ºòÂô®"""
    
    def __init__(self, domain: str = "ar-gcp-cdn.bistudio.com"):
        self.domain = domain
        self.hosts_file = self._get_hosts_file_path()
        self.test_results = []
        self.test_urls = [
            f"http://{domain}/",
            f"https://{domain}/",
            f"http://{domain}/api/health",
            f"https://{domain}/api/health"
        ]
        
        # Á°¨ÁºñÁ†ÅÈÖçÁΩÆ - ‰∏ì‰∏∫Arma Reforger‰ºòÂåñ
        self.config = {
            "backup_hosts": True,
            "test_timeout": 5,
            "test_count": 3,
            "test_http": True,
            "test_https": True,
            "http_timeout": 8,
            "verify_ssl": True,
            "ssl_check_enabled": True,
            "fallback_to_unverified_ssl": True,
            "scoring_weights": {
                "http_base": 50,
                "https_base": 80,
                "ping_base": 20,
                "protocol_complete_bonus": 30
            },
            "multi_dimensional_health": True,
            "health_test_iterations": 3,
            "stability_threshold": 0.8,
            "test_paths": ["/"],
            "show_detailed_results": True,
            "max_workers": 10,
            "adaptive_concurrency": True,
            "fast_mode": True,
            "connection_pool_size": 20,
            "retry_attempts": 2,
            "network_quality_monitoring": True
        }
        
        # Á¶ÅÁî® SSL Ë≠¶Âëä
        urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # ÂàõÂª∫ requests session ÈÖçÁΩÆ
        self.session = requests.Session()
        retry_strategy = Retry(
            total=1,
            backoff_factor=0.1,
            status_forcelist=[429, 500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    
    def _get_hosts_file_path(self) -> str:
        """Ëé∑ÂèñÁ≥ªÁªü hosts Êñá‰ª∂Ë∑ØÂæÑ"""
        system = platform.system().lower()
        if system == "windows":
            return r"C:\Windows\System32\drivers\etc\hosts"
        elif system == "darwin":  # macOS
            return "/etc/hosts"
        else:  # Linux
            return "/etc/hosts"
    
    
    def get_domain_ips(self) -> List[str]:
        """Ëé∑ÂèñÂüüÂêçÁöÑÊâÄÊúâ IP Âú∞ÂùÄ"""
        # ‰ΩøÁî®Â¢ûÂº∫ÁöÑDNSËß£ÊûêÂô®
        resolver = EnhancedDNSResolver(self.domain)
        ip_list = resolver.resolve_all_ips()
        
        if not ip_list:
            print("‚ùå Êó†Ê≥ïËé∑ÂèñÂüüÂêçÁöÑ IP Âú∞ÂùÄ")
            return []
        
        return ip_list
    
    
    def _is_valid_ip(self, ip: str) -> bool:
        """Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúâÊïàÁöÑ IP Âú∞ÂùÄ"""
        try:
            socket.inet_aton(ip)
            return True
        except socket.error:
            return False
    
    def _get_status_description(self, status_code: int) -> str:
        """Ëé∑Âèñ HTTP Áä∂ÊÄÅÁ†ÅÁöÑÊèèËø∞"""
        descriptions = {
            200: "OK",
            201: "Created",
            202: "Accepted",
            204: "No Content",
            301: "Moved Permanently",
            302: "Found",
            303: "See Other",
            304: "Not Modified",
            307: "Temporary Redirect",
            308: "Permanent Redirect",
            400: "Bad Request",
            401: "Unauthorized",
            403: "Forbidden (ÈúÄË¶ÅËÆ§ËØÅ)",
            404: "Not Found",
            405: "Method Not Allowed",
            429: "Too Many Requests",
            500: "Internal Server Error",
            502: "Bad Gateway",
            503: "Service Unavailable",
            504: "Gateway Timeout"
        }
        return descriptions.get(status_code, "Unknown")
    
    def ping_ip(self, ip: str) -> Tuple[str, float, bool]:
        """ÊµãËØïÂçï‰∏™ IP ÁöÑÂª∂Ëøü"""
        try:
            # ‰ΩøÁî® socket ËøûÊé•ÊµãËØïÂª∂Ëøü
            start_time = time.time()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.config["test_timeout"])
            result = sock.connect_ex((ip, 80))
            end_time = time.time()
            sock.close()
            
            if result == 0:
                latency = (end_time - start_time) * 1000  # ËΩ¨Êç¢‰∏∫ÊØ´Áßí
                return ip, latency, True
            else:
                return ip, float('inf'), False
        except Exception as e:
            return ip, float('inf'), False
    
    def test_http_status(self, ip: str) -> Tuple[str, Dict]:
        """ÊµãËØï IP ÁöÑ HTTP Áä∂ÊÄÅÁ†Å"""
        results = {
            'ip': ip,
            'http_status': {},
            'https_status': {},
            'best_http_latency': float('inf'),
            'best_https_latency': float('inf'),
            'http_available': False,
            'https_available': False,
            'overall_score': 0
        }
        
        # ÊµãËØï HTTP
        if self.config.get("test_http", True):
            for path in self.config.get("test_paths", ["/"]):
                url = f"http://{ip}{path}"
                try:
                    start_time = time.time()
                    response = self.session.get(
                        url, 
                        timeout=self.config.get("http_timeout", 10),
                        headers={'Host': self.domain, 'User-Agent': 'HostsOptimizer/1.0'},
                        allow_redirects=True,
                        stream=False
                    )
                    end_time = time.time()
                    latency = (end_time - start_time) * 1000
                    
                    status_code = response.status_code
                    # 403 Êú™ÊéàÊùÉÊòØÊ≠£Â∏∏ÁöÑÔºåËØ¥ÊòéÊúçÂä°Âô®ÂèØÁî®‰ΩÜÈúÄË¶ÅËÆ§ËØÅ
                    # 301/302 ÈáçÂÆöÂêëÂèØËÉΩË°®Á§∫ÈÖçÁΩÆÈóÆÈ¢ò
                    is_success = (200 <= status_code < 300) or (status_code == 403)
                    is_redirect = 300 <= status_code < 400
                    
                    results['http_status'][path] = {
                        'status_code': status_code,
                        'latency': latency,
                        'success': is_success,
                        'is_redirect': is_redirect,
                        'response_size': len(response.content) if response.content else 0
                    }
                    
                    if is_success and latency < results['best_http_latency']:
                        results['best_http_latency'] = latency
                        results['http_available'] = True
                        
                except requests.exceptions.Timeout:
                    results['http_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': 'ËØ∑Ê±ÇË∂ÖÊó∂'
                    }
                except requests.exceptions.ConnectionError:
                    results['http_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': 'ËøûÊé•ÈîôËØØ'
                    }
                except Exception as e:
                    results['http_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': str(e)[:100]  # ÈôêÂà∂ÈîôËØØ‰ø°ÊÅØÈïøÂ∫¶
                    }
        
        # ÊµãËØï HTTPS
        if self.config.get("test_https", True):
            for path in self.config.get("test_paths", ["/"]):
                url = f"https://{ip}{path}"
                try:
                    start_time = time.time()
                    response = self.session.get(
                        url, 
                        timeout=self.config.get("http_timeout", 10),
                        headers={'Host': self.domain, 'User-Agent': 'HostsOptimizer/1.0'},
                        allow_redirects=True,
                        verify=self.config.get("verify_ssl", False),
                        stream=False
                    )
                    end_time = time.time()
                    latency = (end_time - start_time) * 1000
                    
                    status_code = response.status_code
                    # 403 Êú™ÊéàÊùÉÊòØÊ≠£Â∏∏ÁöÑÔºåËØ¥ÊòéÊúçÂä°Âô®ÂèØÁî®‰ΩÜÈúÄË¶ÅËÆ§ËØÅ
                    # 301/302 ÈáçÂÆöÂêëÂèØËÉΩË°®Á§∫ÈÖçÁΩÆÈóÆÈ¢ò
                    is_success = (200 <= status_code < 300) or (status_code == 403)
                    is_redirect = 300 <= status_code < 400
                    
                    results['https_status'][path] = {
                        'status_code': status_code,
                        'latency': latency,
                        'success': is_success,
                        'is_redirect': is_redirect,
                        'response_size': len(response.content) if response.content else 0
                    }
                    
                    if is_success and latency < results['best_https_latency']:
                        results['best_https_latency'] = latency
                        results['https_available'] = True
                        
                except requests.exceptions.Timeout:
                    results['https_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': 'ËØ∑Ê±ÇË∂ÖÊó∂'
                    }
                except requests.exceptions.SSLError:
                    results['https_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': 'SSLËØÅ‰π¶ÈîôËØØ'
                    }
                except requests.exceptions.ConnectionError:
                    results['https_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': 'ËøûÊé•ÈîôËØØ'
                    }
                except Exception as e:
                    results['https_status'][path] = {
                        'status_code': 0,
                        'latency': float('inf'),
                        'success': False,
                        'error': str(e)[:100]  # ÈôêÂà∂ÈîôËØØ‰ø°ÊÅØÈïøÂ∫¶
                    }
        
        # ËÆ°ÁÆóÁªºÂêàËØÑÂàÜ
        score = 0
        redirect_penalty = 0
        
        # Ê£ÄÊü•ÊòØÂê¶ÊúâÈáçÂÆöÂêë
        for path, status in results['http_status'].items():
            if status.get('is_redirect', False):
                redirect_penalty += 2  # ÈáçÂÆöÂêëÊâ£ÂàÜ
        for path, status in results['https_status'].items():
            if status.get('is_redirect', False):
                redirect_penalty += 2  # ÈáçÂÆöÂêëÊâ£ÂàÜ
        
        if results['http_available']:
            score += 10
            if results['best_http_latency'] < 100:
                score += 5
            elif results['best_http_latency'] < 200:
                score += 3
            elif results['best_http_latency'] < 500:
                score += 1
                
        if results['https_available']:
            score += 15  # HTTPS ÊùÉÈáçÊõ¥È´ò
            if results['best_https_latency'] < 100:
                score += 5
            elif results['best_https_latency'] < 200:
                score += 3
            elif results['best_https_latency'] < 500:
                score += 1
        
        # Â∫îÁî®ÈáçÂÆöÂêëÊÉ©ÁΩö
        score = max(0, score - redirect_penalty)
        results['overall_score'] = score
        results['redirect_penalty'] = redirect_penalty
        return ip, results
    
    def test_ips_parallel(self, ips: List[str] = None) -> List[Dict]:
        """Âπ∂Ë°åÊµãËØïÊâÄÊúâ IP Âú∞ÂùÄ"""
        if ips is None:
            ips = self.config['test_ips']
        
        if not ips:
            print("‚ùå Ê≤°ÊúâÂèØÊµãËØïÁöÑ IP Âú∞ÂùÄ")
            return []
        
        print(f"ÂºÄÂßãÊµãËØï {len(ips)} ‰∏™ IP Âú∞ÂùÄ...")
        print("ÊµãËØïÈ°πÁõÆ: PingÂª∂Ëøü + HTTPÁä∂ÊÄÅÁ†Å + SSLËøûÊé•")
        print()
        
        # ‰ΩøÁî®‰ºòÂåñÁöÑÊµãËØïÂô®
        optimized_tester = OptimizedTester(self.config)
        return optimized_tester.test_ips_optimized(ips)
    
    def backup_hosts(self):
        """Â§á‰ªΩ hosts Êñá‰ª∂"""
        if not self.config["backup_hosts"]:
            return
            
        backup_path = f"{self.hosts_file}.backup.{int(time.time())}"
        try:
            with open(self.hosts_file, 'r', encoding='utf-8') as src:
                with open(backup_path, 'w', encoding='utf-8') as dst:
                    dst.write(src.read())
            print(f"Hosts Êñá‰ª∂Â∑≤Â§á‰ªΩÂà∞: {backup_path}")
        except Exception as e:
            print(f"Â§á‰ªΩ hosts Êñá‰ª∂Â§±Ë¥•: {e}")
            raise  # ÈáçÊñ∞ÊäõÂá∫ÂºÇÂ∏∏ÔºåËÆ©GUIËÉΩÂ§üÊçïËé∑
    
    def update_hosts(self, best_ip: str):
        """Êõ¥Êñ∞ hosts Êñá‰ª∂"""
        try:
            # ËØªÂèñÂΩìÂâç hosts Êñá‰ª∂
            with open(self.hosts_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            # ÁßªÈô§ÊóßÁöÑÂüüÂêçËÆ∞ÂΩï
            new_lines = []
            for line in lines:
                if self.domain not in line:
                    new_lines.append(line)
            
            # Ê∑ªÂä†Êñ∞ÁöÑËÆ∞ÂΩï
            new_lines.append(f"{best_ip} {self.domain}\n")
            
            # ÂÜôÂÖ•Êñ∞ÂÜÖÂÆπ
            with open(self.hosts_file, 'w', encoding='utf-8') as f:
                f.writelines(new_lines)
            
            print(f"‚úì Hosts Êñá‰ª∂Â∑≤Êõ¥Êñ∞: {best_ip} {self.domain}")
            
        except PermissionError as e:
            print("‚ùå ÊùÉÈôê‰∏çË∂≥ÔºåÊó†Ê≥ï‰øÆÊîπ hosts Êñá‰ª∂")
            print("ËØ∑‰ª•ÁÆ°ÁêÜÂëòË∫´‰ªΩËøêË°åÊ≠§ËÑöÊú¨")
            raise  # ÈáçÊñ∞ÊäõÂá∫ÂºÇÂ∏∏ÔºåËÆ©GUIËÉΩÂ§üÊçïËé∑
        except Exception as e:
            print(f"‚ùå Êõ¥Êñ∞ hosts Êñá‰ª∂Â§±Ë¥•: {e}")
            raise  # ÈáçÊñ∞ÊäõÂá∫ÂºÇÂ∏∏ÔºåËÆ©GUIËÉΩÂ§üÊçïËé∑
    
    def flush_dns(self):
        """Âà∑Êñ∞ DNS ÁºìÂ≠ò"""
        system = platform.system().lower()
        try:
            if system == "windows":
                subprocess.run(["ipconfig", "/flushdns"], check=True, capture_output=True)
                print("‚úì DNS ÁºìÂ≠òÂ∑≤Âà∑Êñ∞")
            elif system == "darwin":  # macOS
                subprocess.run(["sudo", "dscacheutil", "-flushcache"], check=True, capture_output=True)
                print("‚úì DNS ÁºìÂ≠òÂ∑≤Âà∑Êñ∞")
            else:  # Linux
                subprocess.run(["sudo", "systemctl", "restart", "systemd-resolved"], check=True, capture_output=True)
                print("‚úì DNS ÁºìÂ≠òÂ∑≤Âà∑Êñ∞")
        except Exception as e:
            print(f"‚ö†Ô∏è Âà∑Êñ∞ DNS ÁºìÂ≠òÂ§±Ë¥•: {e}")
            # DNSÂà∑Êñ∞Â§±Ë¥•‰∏çÂ∫îËØ•ÈòªÊ≠¢Êï¥‰∏™ÊµÅÁ®ãÔºåÊâÄ‰ª•‰∏çÊäõÂá∫ÂºÇÂ∏∏
    
    def run_optimization(self):
        """ËøêË°åÂÆåÊï¥ÁöÑ‰ºòÂåñÊµÅÁ®ã"""
        print(f"=== Hosts ÈÄâ‰ºòÂ∑•ÂÖ∑ ===")
        print(f"ÁõÆÊ†áÂüüÂêç: {self.domain}")
        print(f"Hosts Êñá‰ª∂: {self.hosts_file}")
        print()
        
        # Ëé∑ÂèñÂüüÂêçÁöÑÁúüÂÆû IP Âú∞ÂùÄ
        domain_ips = self.get_domain_ips()
        
        if not domain_ips:
            print("‚ùå Êó†Ê≥ïËé∑ÂèñÂüüÂêçÁöÑ IP Âú∞ÂùÄÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÂüüÂêçÊòØÂê¶Ê≠£Á°Æ")
            return
        
        # ÊµãËØïËé∑ÂèñÂà∞ÁöÑ IP Âú∞ÂùÄ
        results = self.test_ips_parallel(domain_ips)
        
        if not results:
            print("‚ùå Ê≤°ÊúâÊâæÂà∞ÂèØÁî®ÁöÑ IP Âú∞ÂùÄ")
            return
        
        # ÊòæÁ§∫ÁªìÊûú
        print(f"\n=== ÊµãËØïÁªìÊûú ===")
        
        # Á≠õÈÄâÂèØÁî®ÁöÑÁªìÊûúÔºàÊúâ HTTP Êàñ HTTPS ÂèØÁî®Ôºâ
        available_results = [r for r in results if r['http_available'] or r['https_available']]
        
        if not available_results:
            print("‚ùå ÊâÄÊúâ IP Âú∞ÂùÄÈÉΩÊó†Ê≥ïÊèê‰æõ HTTP/HTTPS ÊúçÂä°")
            return
        
        print(f"ÊâæÂà∞ {len(available_results)} ‰∏™ÂèØÁî®ÁöÑ IP Âú∞ÂùÄ:")
        print()
        
        for i, result in enumerate(available_results[:10], 1):  # Âè™ÊòæÁ§∫Ââç10‰∏™
            status_info = []
            if result['ping_success']:
                status_info.append(f"Ping: {result['ping_latency']:.1f}ms")
            else:
                status_info.append("Ping: Â§±Ë¥•")
            
            if result['http_available']:
                status_info.append(f"HTTP: {result['best_http_latency']:.1f}ms")
            if result['https_available']:
                status_info.append(f"HTTPS: {result['best_https_latency']:.1f}ms")
            
            status_info.append(f"ËØÑÂàÜ: {result['overall_score']}")
            
            print(f"{i:2d}. {result['ip']:15s} - {' | '.join(status_info)}")
            
            # ÊòæÁ§∫ËØ¶ÁªÜÁöÑ HTTP Áä∂ÊÄÅÁ†Å‰ø°ÊÅØÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
            if self.config.get("show_detailed_results", True):
                if result['http_status']:
                    print(f"    HTTP Áä∂ÊÄÅÁ†Å:")
                    for path, status in result['http_status'].items():
                        if status['success']:
                            size_info = f" ({status.get('response_size', 0)} bytes)" if status.get('response_size', 0) > 0 else ""
                            status_desc = self._get_status_description(status['status_code'])
                            print(f"      {path}: {status['status_code']} {status_desc} ({status['latency']:.1f}ms){size_info}")
                        elif status.get('is_redirect', False):
                            print(f"      {path}: {status['status_code']} ÈáçÂÆöÂêë (ÂèØËÉΩÈÖçÁΩÆÈóÆÈ¢ò)")
                        else:
                            error_msg = status.get('error', 'ËøûÊé•Â§±Ë¥•')
                            print(f"      {path}: Â§±Ë¥• - {error_msg}")
                
                if result['https_status']:
                    print(f"    HTTPS Áä∂ÊÄÅÁ†Å:")
                    for path, status in result['https_status'].items():
                        if status['success']:
                            size_info = f" ({status.get('response_size', 0)} bytes)" if status.get('response_size', 0) > 0 else ""
                            status_desc = self._get_status_description(status['status_code'])
                            ssl_info = f" (SSLÈ™åËØÅ: {'‚úì' if status.get('ssl_verified', True) else '‚úó'})" if 'ssl_verified' in status else ""
                            ssl_warning_info = f" - {status.get('ssl_warning', '')}" if status.get('ssl_warning') else ""
                            print(f"      {path}: {status['status_code']} {status_desc} ({status['latency']:.1f}ms){size_info}{ssl_info}{ssl_warning_info}")
                        elif status.get('is_redirect', False):
                            print(f"      {path}: {status['status_code']} ÈáçÂÆöÂêë (ÂèØËÉΩÈÖçÁΩÆÈóÆÈ¢ò)")
                        else:
                            error_msg = status.get('error', 'ËøûÊé•Â§±Ë¥•')
                            print(f"      {path}: Â§±Ë¥• - {error_msg}")
                
                # ÊòæÁ§∫SSLËØÅ‰π¶‰ø°ÊÅØ
                if result.get('ssl_certificate'):
                    ssl_cert = result['ssl_certificate']
                    print(f"    SSL ËØÅ‰π¶‰ø°ÊÅØ:")
                    
                    if ssl_cert.get('ssl_available', False):
                        print(f"      SSLËøûÊé•: ÂèØÁî® ‚úì")
                        
                        # ËØÅ‰π¶ÊúâÊïàÊÄß
                        if ssl_cert.get('certificate_valid', False):
                            print(f"      ËØÅ‰π¶ÊúâÊïàÊÄß: ÊúâÊïà ‚úì")
                        else:
                            print(f"      ËØÅ‰π¶ÊúâÊïàÊÄß: Êó†Êïà ‚úó")
                        
                        # ‰∏ªÊú∫ÂêçÈ™åËØÅ
                        if ssl_cert.get('hostname_verified', False):
                            print(f"      ‰∏ªÊú∫ÂêçÈ™åËØÅ: ÂåπÈÖç ‚úì")
                        else:
                            print(f"      ‰∏ªÊú∫ÂêçÈ™åËØÅ: ‰∏çÂåπÈÖç ‚úó")
                        
                        # ÂüüÂêçÂåπÈÖçÊ£ÄÊü•
                        if ssl_cert.get('domain_match', False):
                            print(f"      ÂüüÂêçÂåπÈÖç: ÂåπÈÖç ‚úì")
                        else:
                            print(f"      ÂüüÂêçÂåπÈÖç: ‰∏çÂåπÈÖç ‚úó")
                        
                        # ÊòæÁ§∫ËØÅ‰π¶ËØ¶ÊÉÖÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
                        if ssl_cert.get('issuer'):
                            issuer = ssl_cert.get('issuer', {})
                            org_name = issuer.get('organizationName', issuer.get('commonName', 'Unknown'))
                            print(f"      È¢ÅÂèëËÄÖ: {org_name}")
                        
                        if ssl_cert.get('not_after'):
                            print(f"      ÊúâÊïàÊúüËá≥: {ssl_cert.get('not_after', 'Unknown')}")
                            days_left = ssl_cert.get('days_until_expiry', -1)
                            if days_left > 0:
                                print(f"      Ââ©‰ΩôÂ§©Êï∞: {days_left} Â§©")
                            elif days_left == 0:
                                print(f"      ËØÅ‰π¶‰ªäÂ§©ËøáÊúü")
                            else:
                                print(f"      ËØÅ‰π¶Â∑≤ËøáÊúü")
                        
                        # ÊòæÁ§∫Ë≠¶Âëä‰ø°ÊÅØ
                        if ssl_cert.get('certificate_warning'):
                            print(f"      Ë≠¶Âëä: {ssl_cert.get('certificate_warning')}")
                    else:
                        print(f"      SSLËøûÊé•: ‰∏çÂèØÁî® ‚úó")
                        print(f"      ÈîôËØØ: {ssl_cert.get('error', 'Unknown error')}")
                        print(f"      ÈîôËØØÁ±ªÂûã: {ssl_cert.get('error_type', 'Unknown')}")
                
                # ÊòæÁ§∫ÂÅ•Â∫∑Ê£ÄÊµãËØ¶ÁªÜ‰ø°ÊÅØ
                if result.get('health_info'):
                    health_info = result['health_info']
                    print(f"    ÂÅ•Â∫∑Ê£ÄÊµãËØ¶ÊÉÖ:")
                    print(f"      ÁªºÂêàÂÅ•Â∫∑ËØÑÂàÜ: {health_info.get('overall_health_score', 0):.1f} ({health_info.get('health_grade', 'F')})")
                    
                    # Á®≥ÂÆöÊÄß‰ø°ÊÅØ
                    if health_info.get('stability'):
                        stability = health_info['stability']
                        print(f"      ËøûÊé•Á®≥ÂÆöÊÄß: {stability.get('stability_score', 0):.2f}")
                        print(f"      ÊàêÂäüÁéá: {stability.get('success_rate', 0):.1%}")
                        print(f"      Âπ≥ÂùáÂª∂Ëøü: {stability.get('avg_latency', 0):.1f}ms")
                        print(f"      Âª∂ËøüÊ†áÂáÜÂ∑Æ: {stability.get('latency_std', 0):.1f}ms")
                    
                    
                    # SSLË¥®Èáè‰ø°ÊÅØ
                    if health_info.get('ssl_quality'):
                        ssl_quality = health_info['ssl_quality']
                        if ssl_quality.get('cert_score', 0) > 0:
                            print(f"      SSLË¥®ÈáèËØÑÂàÜ: {ssl_quality.get('cert_score', 0):.1f} ({ssl_quality.get('ssl_grade', 'F')})")
                            print(f"      ËØÅ‰π¶ÊúâÊïàÊúü: {ssl_quality.get('cert_validity_days', 0)} Â§©")
                            print(f"      ËØÅ‰π¶È¢ÅÂèëËÄÖ: {ssl_quality.get('cert_issuer', 'Unknown')}")
                            print(f"      Âä†ÂØÜÁÆóÊ≥ï: {ssl_quality.get('cert_algorithm', 'Unknown')}")
                            print(f"      Âä†ÂØÜÂº∫Â∫¶: {ssl_quality.get('cert_strength', 'Unknown')} bits")
                    
                    # ÂçèËÆÆÊîØÊåÅ‰ø°ÊÅØ
                    if health_info.get('protocol_support'):
                        protocol = health_info['protocol_support']
                        print(f"      ÂçèËÆÆÊîØÊåÅËØÑÂàÜ: {protocol.get('protocol_score', 0):.1f}")
                        print(f"      HTTPÊîØÊåÅ: {'‚úì' if protocol.get('http_support') else '‚úó'}")
                        print(f"      HTTPSÊîØÊåÅ: {'‚úì' if protocol.get('https_support') else '‚úó'}")
                        print(f"      HTTP/2ÊîØÊåÅ: {'‚úì' if protocol.get('http2_support') else '‚úó'}")
                    
                    # Âú∞ÁêÜ‰ΩçÁΩÆ‰ø°ÊÅØ
                    if health_info.get('geographic'):
                        geo = health_info['geographic']
                        print(f"      Âú∞ÁêÜ‰ΩçÁΩÆËØÑÂàÜ: {geo.get('geo_score', 0):.2f}")
                        print(f"      ÁΩëÁªúÂå∫Âüü: {geo.get('region', 'Unknown')}")
                        print(f"      ÊúçÂä°Êèê‰æõÂïÜ: {geo.get('provider', 'Unknown')}")
            print()
        
        best_result = available_results[0]
        print(f"ÊúÄ‰ºò IP: {best_result['ip']}")
        if best_result['https_available']:
            print(f"  HTTPS Âª∂Ëøü: {best_result['best_https_latency']:.2f}ms")
        if best_result['http_available']:
            print(f"  HTTP Âª∂Ëøü: {best_result['best_http_latency']:.2f}ms")
        if best_result['ping_success']:
            print(f"  Ping Âª∂Ëøü: {best_result['ping_latency']:.2f}ms")
        print(f"  ÁªºÂêàËØÑÂàÜ: {best_result['overall_score']}")
        
        # ÊòæÁ§∫ÈáçÂÆöÂêëÊÉ©ÁΩö‰ø°ÊÅØ
        if best_result.get('redirect_penalty', 0) > 0:
            print(f"  ÈáçÂÆöÂêëÊÉ©ÁΩö: -{best_result['redirect_penalty']} ÂàÜ")
        
        # ËØ¢ÈóÆÊòØÂê¶Êõ¥Êñ∞
        while True:
            choice = input(f"\nÊòØÂê¶Êõ¥Êñ∞ hosts Êñá‰ª∂? (y/n): ").lower().strip()
            if choice in ['y', 'yes', 'ÊòØ']:
                break
            elif choice in ['n', 'no', 'Âê¶']:
                print("Â∑≤ÂèñÊ∂àÊõ¥Êñ∞")
                return
            else:
                print("ËØ∑ËæìÂÖ• y Êàñ n")
        
        # Â§á‰ªΩÂπ∂Êõ¥Êñ∞
        self.backup_hosts()
        self.update_hosts(best_result['ip'])
        
        # Âà∑Êñ∞ DNS
        flush_choice = input("ÊòØÂê¶Âà∑Êñ∞ DNS ÁºìÂ≠ò? (y/n): ").lower().strip()
        if flush_choice in ['y', 'yes', 'ÊòØ']:
            self.flush_dns()
        
        print("\n‚úì ‰ºòÂåñÂÆåÊàê!")


def main():
    """‰∏ªÂáΩÊï∞"""
    try:
        optimizer = HostsOptimizer()
        optimizer.run_optimization()
    except KeyboardInterrupt:
        print("\n\nÁî®Êà∑‰∏≠Êñ≠Êìç‰Ωú")
    except Exception as e:
        print(f"\n‚ùå ÂèëÁîüÈîôËØØ: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main()
